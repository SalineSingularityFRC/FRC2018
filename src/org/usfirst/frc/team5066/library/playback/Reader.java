package src.org.usfirst.frc.team5066.library.playback;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

/**
 * Class for reading JSON files created by the
 * {@link org.usfirst.frc.team5066.library.playback.Reader Reader} class.
 * 
 * @author Saline Singularity 5066
 *
 */
public class Reader {
	private BufferedReader br;
	private File file;
	private Iterator<JSONObject> iterator;
	private JSONArray data;
	private JSONObject completeObject, currentObject, previousObject;
	private JSONParser parser;

	/**
	 * Constructor for {@link org.usfirst.frc.team5066.library.playback.Reader
	 * Reader}.
	 * 
	 * @param fileURL
	 *            Where the file is located
	 * @throws FileNotFoundException
	 *             If the file does not exist
	 * @throws ParseException
	 *             If the file is not in the proper format
	 */
	@SuppressWarnings("unchecked")
	public Reader(String fileURL) throws FileNotFoundException, ParseException {
		parser = new JSONParser();

		try {
			file = new File(fileURL);
			if (!file.exists()) {
				throw new FileNotFoundException();
			}

			br = new BufferedReader(new FileReader(file));
			completeObject = (JSONObject) parser.parse(br);
			data = (JSONArray) ((JSONObject) completeObject.get("recording")).get("data");
			currentObject = (JSONObject) data.get(0);
			previousObject = currentObject;
			iterator = data.iterator();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}

	/**
	 * Reads global attribute from the JSON file
	 * 
	 * @param key
	 *            Which attribute to find
	 * @return The value generated by the key
	 */
	public String readAttribute(String key) {
		return completeObject.get(key).toString();
	}

	/**
	 * Sets iterator to the beginning (to reread file)
	 */
	@SuppressWarnings("unchecked")
	public void resetIterator() {
		iterator = data.iterator();
	}

	/**
	 * Finds the next piece of data to use based on the time elapsed. Use
	 * {@link org.usfirst.frc.team5066.library.playback.Reader#resetIterator
	 * resetIterator} to search from the beginning
	 * 
	 * @return The next data
	 */
	public JSONObject getDataAtTime(long time) {
		// If we have reached the end of the list, there are no more data
		if (currentObject == null) {
			return previousObject;
		}

		// If we have moved past the previous element's time, find the next
		// element
		if ((long) currentObject.get("time") <= time) {
			// Repeat this until the time variable falls between the previous
			// and current elements' times
			do {
				previousObject = currentObject;

				// See if we have reached the end of the data
				if (iterator.hasNext()) {
					currentObject = iterator.next();
				} else {
					currentObject = null;
				}
			} while (currentObject != null && (long) currentObject.get("time") <= time);

			// Return the object which the time has passed
			return previousObject;
		} else {
			// Return the object which the time has passed
			return previousObject;
		}
	}
	
    public boolean isDone(long time) {
        return (Long) ((JSONObject) data.get(data.size() - 1)).get("time") < time;
    }
	
	public void close() {
		try {
			br.close();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}
}
